using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;

namespace HSDArcSourceGenerator
{
#pragma warning disable RS1035

    // 该生成器会查找带有 [AutoSerializable] 特性的类
    [Generator]
    public class AutoSerializableIncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 添加 AutoSerializableAttribute 的源代码，确保目标项目中存在该特性
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("AutoSerializableAttribute.g.cs", SourceText.From(@"
using System;
namespace FEHagemu.HSDArchiveOld
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class AutoSerializableAttribute : Attribute
    {
    }
    public interface ISerializable
    {
        public ISerializable Deserialize(HSDArchiveReader reader);
    }
}
", Encoding.UTF8));
            });

            // 创建一个语法过滤器，查找所有带有属性列表的类声明
            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
                .Where(static m => m != null);

            // 把编译单元和所有候选的类结合起来
            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
                context.CompilationProvider.Combine(classDeclarations.Collect());

            // 根据上面的信息生成代码
            context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
            {
                var (compilation, classes) = source;
                foreach (var classDeclaration in classes)
                {
                    var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                    var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                    if (classSymbol == null)
                        continue;

                    // 仅处理标记了 [AutoSerializable] 的类
                    bool hasAttribute = classSymbol.GetAttributes()
                        .Any(ad => ad.AttributeClass?.ToDisplayString() == "FEHagemu.HSDArchiveOld.AutoSerializableAttribute");
                    if (!hasAttribute)
                        continue;

                    // 生成对应的反序列化器代码
                    string generatedCode = GenerateDeserializerCode(classSymbol);
                    /*{classSymbol.Name}_*/
                    spc.AddSource($"{classSymbol.Name}_Deserialize.g.cs", SourceText.From(generatedCode, Encoding.UTF8));
                }
            });
        }

        private static string GenerateDeserializerCode(INamedTypeSymbol classSymbol)
        {
            var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? ""
                : classSymbol.ContainingNamespace.ToDisplayString();
            var className = classSymbol.Name;
            var sb = new StringBuilder();

            // 文件头自动生成标记
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// 此代码由 AutoSerializableIncrementalGenerator 生成");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.IO;");
            sb.AppendLine("using System.Text;");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }

            // 生成静态反序列化器类
            sb.AppendLine($"    public partial class {className} : ISerializable"/*{className}*/);
            sb.AppendLine("    {");
            sb.AppendLine($"        public ISerializable Deserialize(HSDArchiveReader reader)");
            sb.AppendLine("        {");

            // 遍历所有字段（这里只处理字段，如有需要可扩展支持属性）
            foreach (var member in classSymbol.GetMembers().OfType<IFieldSymbol>())
            {
                if (member.IsStatic) continue;
                string fieldName = member.Name;
                string fieldType = member.Type.ToDisplayString();
                string readExpression = GetReadExpression(member.Type, member.GetAttributes().FirstOrDefault(ad => ad.AttributeClass?.ToDisplayString() == "FEHagemu.HSDArchiveOld.HSDFieldPropertyAttribute"));
                if (string.IsNullOrEmpty(readExpression))
                {
                    sb.AppendLine($"            // 字段 {fieldName} 类型 {fieldType} 不支持自动反序列化");
                    sb.AppendLine($"            throw new NotSupportedException(\"字段 {fieldName} 类型 {fieldType} 不支持自动反序列化。\");");
                }
                else
                {
                    sb.AppendLine($"            this.{fieldName} = {readExpression};");
                }
            }
            sb.AppendLine("            return this;");
            sb.AppendLine("        }");
            sb.AppendLine();
            // 为 string 类型生成辅助读取方法（假设存储格式：int 长度 + 字节数组）
            sb.AppendLine("    }");

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine("}");
            }
            return sb.ToString();
        }

        /// <summary>
        /// 根据字段类型返回对应的读取表达式
        /// </summary>
        private static string GetReadExpression(ITypeSymbol typeSymbol, AttributeData? data)
        {
            var x = typeSymbol.OriginalDefinition.ToDisplayString();
            if (data == null) {
                switch (typeSymbol.OriginalDefinition.ToDisplayString())
                {
                    case "ushort":
                        return "reader.ReadUInt16()";
                    case "int":
                        return "reader.ReadInt32()";
                    case "uint":
                        return "reader.ReadUInt32()";
                    case "long":
                        return "reader.ReadInt64()";
                    case "ulong":
                        return "reader.ReadUInt64()";
                    case "float":
                        return "reader.ReadSingle()";
                    case "double":
                        return "reader.ReadDouble()";
                    case "string":
                        return "ReadString(reader)";
                    case "FEHagemu.HSDArchiveOld.DataPtr<T>":
                        return $"reader.ReadPtr<{((INamedTypeSymbol)typeSymbol).TypeArguments[0].ToDisplayString()}>()";
                    default:
                        throw new NotImplementedException($"{typeSymbol.ToDisplayString()} cannot be read, no reading method is implemented");
                }
            } else
            {
                ulong key = (ulong)data.NamedArguments.First(arg => arg.Key == "Key").Value.Value!;
                switch (typeSymbol.ToDisplayString())
                {
                    case "sbyte":
                        return $"reader.ReadSByte({(sbyte)key})";
                    case "byte":
                        return $"reader.ReadByte({(byte)key})";
                    case "short":
                        return $"reader.ReadShort({(short)key})";
                    case "ushort":
                        return $"reader.ReadUShort({(ushort)key})";
                    case "int":
                        return $"reader.ReadInt({(int)key})";
                    case "uint":
                        return $"reader.ReadUInt({(uint)key})";
                    case "long":
                        return $"reader.ReadLong({(long)key})";
                    case "ulong":
                        return $"reader.ReadULong({key})";
                    case "DataPtr<String>":
                        return $"reader.ReadPtr<XString>())";
                    default:
                        throw new NotImplementedException($"{typeSymbol.ToDisplayString()} cannot be read, no reading method is implemented");
                }
            }
            
        }

        private static string GetArrayReadExpression(ITypeSymbol arrayTypeSymbol, AttributeData? data)
        {
            if (arrayTypeSymbol is IArrayTypeSymbol ats)
            {
                int size = (int)data!.NamedArguments.First(arg => arg.Key == "Size").Value.Value!;
            }
            return string.Empty;
        }

        private static string GetXorKey(ITypeSymbol typeSymbol, AttributeData? data)
        {
            if (data is null)
            {
                return string.Empty;
            } else
            {
                ulong key = (ulong)data!.NamedArguments.First(arg => arg.Key == "Key").Value.Value!;
                switch (typeSymbol.ToDisplayString())
                {
                    case "sbyte":
                        return $"{(sbyte)key}";
                    case "byte":
                        return $"reader.ReadByte({(byte)key})";
                    case "short":
                        return $"reader.ReadShort({(short)key})";
                    case "ushort":
                        return $"reader.ReadUShort({(ushort)key})";
                    case "int":
                        return $"reader.ReadInt({(int)key})";
                    case "uint":
                        return $"reader.ReadUInt({(uint)key})";
                    case "long":
                        return $"reader.ReadLong({(long)key})";
                    case "ulong":
                        return $"reader.ReadULong({key})";
                    case "DataPtr<String>":
                        return $"reader.ReadPtr<XString>())";
                    default:
                        throw new NotImplementedException($"{typeSymbol.ToDisplayString()} cannot be read, no reading method is implemented");
                }
            }
            
        }
    }
}

